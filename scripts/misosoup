#!/usr/bin/env python
"""MiSoS(oup)"""

import argparse
import logging
import os
import yaml
import glob

from collections import defaultdict

from reframed import Community, solver_instance
import gurobipy as gp

from misolib.readwrite import load_models, read_compounds
from misolib.readwrite import write_minimal_suppliers
from misolib.common import get_reaction_name
from misolib.load import setup_medium, introduce_binary_variables
from misolib.solve import minimal_suppliers, minimal_communities
from misolib.getters import get_biomass, get_exchange_reactions
from misolib.validate import validate_solution_dict

compute_function = defaultdict(lambda: minimal_suppliers, {"min": minimal_communities})


def compute_solution(
    org_id,
    base_medium,
    carbon_source,
    community,
    parsimony,
    community_size,
    minimal_growth,
):
    """Setup and execute misosoup."""
    with gp.Env() as env:
        solver = solver_instance(community.merged_model, env=env)

        introduce_binary_variables(community, solver)

        setup_medium(
            community.merged_model,
            solver,
            base_medium,
            [carbon_source],
        )

        solution = compute_function[org_id](
            org_id,
            community,
            solver,
            values=(
                get_biomass(community) + get_exchange_reactions(community.merged_model)
            ),
            community_size=community_size,
            parsimony=parsimony,
            minimal_growth=minimal_growth,
        )

        return (org_id, solution)


def main(args):
    """Main function."""
    input_paths = glob.glob(args.input[0]) if len(args.input) == 1 else args.input
    models = load_models(args.input)
    base_medium = read_compounds(args.base_medium)

    community = Community("CoI", models, copy_models=False)

    solution = defaultdict(dict)

    for carbon_source in args.carbon_sources:
        org_id, sol = compute_solution(
            args.strain,
            base_medium=base_medium,
            carbon_source=args.exchange_format.format(carbon_source),
            community=community,
            community_size=args.community_size,
            parsimony=args.parsimony,
            minimal_growth=args.minimal_growth,
        )

        solution[carbon_source][org_id] = sol

    output_dict = {
        k: {
            org: [{var: rate for var, rate in s.values.items() if rate} for s in sol]
            if sol
            else [{f"Growth_{org}": 0}]
            for org, sol in v.items()
        }
        for k, v in solution.items()
    }

    if args.validate:
        validate_solution_dict(output_dict, args.exchange_format)

    output = yaml.dump(output_dict)

    if args.output:
        if not os.path.exists(os.path.dirname(args.output)):
            os.makedirs(os.path.dirname(args.output))
        with open(args.output, "w") as fd:
            fd.write(output)
    else:
        print(output)


if __name__ == "__main__":
    parser = argparse.ArgumentParser(
        description="Compute minimal supplying communities with MiSoS(oup)."
    )
    parser.add_argument(
        "input", nargs="+", type=str, help="List or wildcard for model paths."
    )
    parser.add_argument(
        "-o",
        "--output",
        type=str,
        help="Output file. Format: YAML. If not supplied, will print to stdout.",
    )
    parser.add_argument(
        "--base-medium",
        type=str,
        required=True,
        help="Path to base medium. Format: YAML. File needs to contain list with exchange reactions, e.g. `EX_h_e`.",
    )
    parser.add_argument(
        "--carbon-sources",
        type=str,
        nargs="+",
        required=True,
        help="List of carbon sources based on their id, e.g. `ac`",
    )
    parser.add_argument(
        "--strain",
        type=str,
        default="min",
        help="Focal strain model id. If no strain is provided, we compute minimal communities.",
    )
    parser.add_argument(
        "--parsimony", action="store_true", help="Compute parsimony solution."
    )
    parser.add_argument(
        "--community-size",
        type=int,
        default=0,
        help="Maximum community size. Default: 0 (Arbitrary).",
    )
    parser.add_argument(
        "--minimal-growth",
        type=float,
        default=0.01,
        help="Minimal required growth for strain or community.",
    )
    parser.add_argument(
        "--exchange-format",
        type=str,
        default="EX_{}_e",
        help=(
            "Format string that specifies how compounds are mapped to exchange reactions, "
            "default: `EX_{}_e`, will map `ac` to `EX_ac_e`"
        ),
    )
    parser.add_argument(
        "--validate",
        action="store_true",
        help="Validate solution. Numerical consistency will verified.",
    )
    parser.add_argument("--log", default="INFO", help="Log level. Default: INFO")

    args_parsed = parser.parse_args()

    logging.basicConfig(level=args_parsed.log, format="%(asctime)s %(message)s")

    main(args_parsed)
